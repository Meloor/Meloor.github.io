<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>how to use hexo</title>
    <link href="/categories/uncategorized/how-to-use-hexo.html"/>
    <url>/categories/uncategorized/how-to-use-hexo.html</url>
    
    <content type="html"><![CDATA[<h1 id="how-to-use-hexo"><a href="#how-to-use-hexo" class="headerlink" title="how to use hexo"></a>how to use hexo</h1><p>wait for writting…</p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>研究中…</p><h3 id="1-hexo-serer"><a href="#1-hexo-serer" class="headerlink" title="1. hexo-serer"></a>1. hexo-serer</h3><p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。</p><blockquote><p>npm install hexo-server –save</p></blockquote><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p><a href="https://hexo.io/zh-cn/docs/configuration">hexo配置</a></p><h2 id="writting"><a href="#writting" class="headerlink" title="writting"></a>writting</h2><p><a href="https://hexo.io/zh-cn/docs/writing">hexo写作</a><br>new, layout=[post,page,draft]分别生成到不同目录,page与about,categories页面同级</p><blockquote><p>hexo new [layout] [title]</p></blockquote><p>通过 publish 命令将草稿移动到 source/_posts 文件夹,该命令的使用方式与 new 十分类似，相当于new之后进行modify(layout)</p><blockquote><p>hexo publish [layout]  [title]<br>hexo publish post “draft_post”<br>hexo publish page “draft_page”</p></blockquote><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，(scaffolds文件夹默认有[post.md,page.md,draft.md]三个layout的模板),例如：</p><blockquote><p>hexo new photo “My Gallery”</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java访问权限（类、接口、内部类、内部接口）</title>
    <link href="/categories/web/java/Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%88%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3%EF%BC%89.html"/>
    <url>/categories/web/java/Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%88%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3%EF%BC%89.html</url>
    
    <content type="html"><![CDATA[<p>ref:</p><ul><li><a href="https://www.runoob.com/java">菜鸟教程-java教程</a></li><li>《Java编程思想》【Bruce Eckel著】</li></ul><h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>有些类型只能使用部分访问权限修饰符，并且有默认修饰符</p><blockquote><p>public, 所有类可见<br>private, 当前类可见<br>default（缺省）, 同一包内可见<br>protected, 同一包内可见，不同包的子孙类可见</p></blockquote><h2 id="类的访问权限（不含内部类）"><a href="#类的访问权限（不含内部类）" class="headerlink" title="类的访问权限（不含内部类）"></a>类的访问权限（不含内部类）</h2><p><strong>类只有public,default两种访问形式</strong></p><ul><li>default类<ul><li> 只能被同一包内的其他类访问。</li></ul></li><li>public类<ul><li>也可以被其他包中的类访问。</li><li>每个编译单元（文件）都只能有一个public类<br>public类名称必须和其所在文件同名</li></ul></li></ul><p>一个编译单元（文件）中可以没又pubic类，但是不太常用<br><strong>类不能是private, protected的</strong></p><ul><li>private构造器：<ul><li>如果不希望任何人（包括同一个包内）对该类有访问权限，可以把所有的构造器都指定为private，这样只有自身static方法可以创建该类的对象，其他类无法使用构造器。</li><li>但是具有该类访问权限的其他包可以调用该类的public/default static成员，因为static成员不需要实例。</li></ul></li></ul><h2 id="接口的访问权限（不含内部接口）"><a href="#接口的访问权限（不含内部接口）" class="headerlink" title="接口的访问权限（不含内部接口）"></a>接口的访问权限（不含内部接口）</h2><ul><li><strong>接口只有public, default两种访问形式</strong></li><li>接口是隐式抽象(abstract)的，当声明时不必使用abstract关键字</li><li>接口中的方法会被隐式的指定为 public abstract（且只能是）</li><li>接口中的变量会被隐式的指定为 public static final（且只能是）（即类常量）</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法</li><li>JDK 1.8 以后，接口里可以有静态方法和方法体了。</li></ul><h2 id="内部类和内部接口的访问权限（从外部访问）"><a href="#内部类和内部接口的访问权限（从外部访问）" class="headerlink" title="内部类和内部接口的访问权限（从外部访问）"></a>内部类和内部接口的访问权限（从外部访问）</h2><h3 id="非静态内部类和内部接口"><a href="#非静态内部类和内部接口" class="headerlink" title="非静态内部类和内部接口"></a>非静态内部类和内部接口</h3><p>修饰符：</p><blockquote><p>public, 所有类可见<br>private, 当前类可见<br>default, 同一包内可见</p></blockquote><p><strong>把内部类当成是外部类的一个成员变量来理解</strong>，class本来就是一个类类型，由class关键字定义的类相当于是创建了一个class实例（变量）。</p><p>使用方式，需创建外部类/接口的实例：<code>Outer.Inner inner = new Outer.new Inner();</code></p><h3 id="静态内部类和静态内部接口"><a href="#静态内部类和静态内部接口" class="headerlink" title="静态内部类和静态内部接口"></a>静态内部类和静态内部接口</h3><p>就像使用静态方法一样，不需要创建外部类/接口的实例：<code>Outer.Inner inner = new Outer.Inner();</code></p><p><strong>接口中的内部类是隐式public static的</strong>，不能为private<br><strong>接口中的内部接口也是隐式public static的</strong>，不能为private<br><strong>示例代码中均为接口中的内部类和内部接口</strong>，类中的内部类和内部接口同理。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>文件目录结构：InnerDemo和InnerDemo2属于不同的包</p><blockquote><p>|-InnerDemo<br>| |-OuterClass.java<br>| |-OuterClass2.java<br>| |-OuterInterface.java<br>| |-OuterInterface.java<br>| |-Test.java<br>|<br>|-InnerDemo2<br>| |-Test.java</p></blockquote><p>OuterClass.java：外部类嵌套内部类</p><figure class="highlight java"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-lrdh30lax5lwsb"></i><span>java</span><div class="collapse" id="collapse-lrdh30lax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span>&#123;&#125;    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass2</span>&#123;&#125;    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass3</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>OuterClass2.java：外部类嵌套内部接口</p><figure class="highlight java"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-fgm1kplax5lwsb"></i><span>java</span><div class="collapse" id="collapse-fgm1kplax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass2</span> &#123;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InnerInterface</span>&#123;&#125;    <br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InnerInterface2</span>&#123;&#125;    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InnerInterface3</span>&#123;&#125;    <br>    <span class="hljs-comment">//InnerInterface实现类    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterfaceImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterface</span>&#123;&#125;    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterfaceImp2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterface</span>&#123;&#125;    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterfaceImp3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterface</span>&#123;&#125;    <br>    <span class="hljs-comment">//InnerInterface2实现类    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterface2Imp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterface2</span>&#123;&#125;   <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterface2Imp2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterface2</span>&#123;&#125;    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterface2Imp3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterface2</span>&#123;&#125;    <br>    <span class="hljs-comment">//InnerInterface3实现类    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterface3Imp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterface3</span>&#123;&#125;   <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterface3Imp2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterface3</span>&#123;&#125;    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterface3Imp3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterface3</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>OuterInterface.java：外部接口嵌套内部类</p><figure class="highlight java"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-6m9huglax5lwsb"></i><span>java</span><div class="collapse" id="collapse-6m9huglax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*接口中的内部类是隐式public static的，不能为private*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OuterInterface</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span>&#123;&#125;<br>    <span class="hljs-comment">//    private class InnerClass3&#123;&#125;//非法</span><br>&#125;<br></code></pre></td></tr></table></div></figure><p>OuterInterface2.java：外部接口嵌套内部接口</p><figure class="highlight java"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-qyogo1lax5lwsb"></i><span>java</span><div class="collapse" id="collapse-qyogo1lax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*接口中的内部类是隐式public static的，不能为private</span><br><span class="hljs-comment">接口中的内部接口也是隐式public static的，不能为private */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OuterInterface2</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InnerInterface</span>&#123;&#125;<br>    <span class="hljs-comment">//    private interface IninerInterface3&#123;&#125;//非法    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerInterfaceImp</span> <span class="hljs-keyword">implements</span> <br>    <span class="hljs-title class_">InnerInterface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>InnerDemo/Test.java：测试类</p><figure class="highlight java"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-vrjl1elax5lwsb"></i><span>java</span><div class="collapse" id="collapse-vrjl1elax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <br>        <span class="hljs-comment">//外部类嵌套的内部类        </span><br>        OuterClass.<span class="hljs-type">InnerClass</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>();        <br>        OuterClass.<span class="hljs-type">InnerClass2</span> <span class="hljs-variable">inner2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass2</span>();        <br>        OuterClass.<span class="hljs-type">InnerClass3</span> <span class="hljs-variable">inner3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">nnerClass3</span>();<span class="hljs-comment">//非法</span><br>        <span class="hljs-comment">//外部类嵌套的内部接口       </span><br>        OuterClass2.<span class="hljs-type">InnerInterface</span> <span class="hljs-variable">innerInterface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterfaceImp</span>();        <br>        OuterClass2.<span class="hljs-type">InnerInterface</span> <span class="hljs-variable">innerInterface_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterfaceImp2</span>();       <br>        OuterClass2.<span class="hljs-type">InnerInterface</span> <span class="hljs-variable">innerInterface_3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterfaceImp3</span>();<span class="hljs-comment">//非法        </span><br>        OuterClass2.<span class="hljs-type">InnerInterface2</span> <span class="hljs-variable">innerInterface2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface2Imp</span>();        <br>        OuterClass2.<span class="hljs-type">InnerInterface2</span> <span class="hljs-variable">innerInterface2_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface2Imp2</span>();        <br>        OuterClass2.<span class="hljs-type">InnerInterface2</span> <span class="hljs-variable">innerInterface2_3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface2Imp3</span>();<span class="hljs-comment">//非法        </span><br>        OuterClass2.<span class="hljs-type">InnerInterface3</span> <span class="hljs-variable">innerInterface3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface3Imp</span>();<span class="hljs-comment">//非法        </span><br>        OuterClass2.<span class="hljs-type">InnerInterface3</span> <span class="hljs-variable">innerInterface3_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface3Imp2</span>();<span class="hljs-comment">//非法        </span><br>        OuterClass2.<span class="hljs-type">InnerInterface3</span> <span class="hljs-variable">innerInterface3_3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface3Imp3</span>();<span class="hljs-comment">//非法       </span><br>        <span class="hljs-comment">//外部接口嵌套的内部类        </span><br>        OuterInterface.<span class="hljs-type">InnerClass</span> <span class="hljs-variable">innerClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterInterface</span>.InnerClass();        <br>        <span class="hljs-comment">//外部接口嵌套的内部接口        </span><br>        OuterInterface2.<span class="hljs-type">InnerInterface</span> <span class="hljs-variable">innerInterface1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">uterInterface2</span>.InnerInterfaceImp();    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>InnerDemo2/Test.java：测试类，同上，但是包不同，语法识别结果不同</p><figure class="highlight java"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-gy78s1lax5lwsb"></i><span>java</span><div class="collapse" id="collapse-gy78s1lax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <br>        <span class="hljs-comment">//外部类嵌套的内部类       </span><br>        OuterClass.<span class="hljs-type">InnerClass</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>();       <br>        OuterClass.<span class="hljs-type">InnerClass2</span> <span class="hljs-variable">inner2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass2</span>();        <br>        OuterClass.<span class="hljs-type">InnerClass3</span> <span class="hljs-variable">inner3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass3</span>();<span class="hljs-comment">//非法        </span><br>        <span class="hljs-comment">//外部类嵌套的内部接口        </span><br>        OuterClass2.<span class="hljs-type">InnerInterface</span> <span class="hljs-variable">innerInterface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterfaceImp</span>();        <br>        OuterClass2.<span class="hljs-type">InnerInterface</span> <span class="hljs-variable">innerInterface_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterfaceImp2</span>();       <br>        OuterClass2.<span class="hljs-type">InnerInterface</span> <span class="hljs-variable">innerInterface_3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterfaceImp3</span>();<span class="hljs-comment">//非法        </span><br>        OuterClass2.<span class="hljs-type">InnerInterface2</span> <span class="hljs-variable">innerInterface2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface2Imp</span>();       <br>        OuterClass2.<span class="hljs-type">InnerInterface2</span> <span class="hljs-variable">innerInterface2_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface2Imp2</span>();        <br>        OuterClass2.<span class="hljs-type">InnerInterface2</span> <span class="hljs-variable">innerInterface2_3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface2Imp3</span>();<span class="hljs-comment">//非法        </span><br>        OuterClass2.<span class="hljs-type">InnerInterface3</span> <span class="hljs-variable">innerInterface3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface3Imp</span>();<span class="hljs-comment">//非法        </span><br>        OuterClass2.<span class="hljs-type">InnerInterface3</span> <span class="hljs-variable">innerInterface3_2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface3Imp2</span>();<span class="hljs-comment">//非法        </span><br>        OuterClass2.<span class="hljs-type">InnerInterface3</span> <span class="hljs-variable">innerInterface3_3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass2</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerInterface3Imp3</span>();<span class="hljs-comment">//非法        </span><br>        <span class="hljs-comment">//外部接口嵌套的内部类        </span><br>        OuterInterface.<span class="hljs-type">InnerClass</span> <span class="hljs-variable">innerClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterInterface</span>.InnerClass();        <br>        <span class="hljs-comment">//外部接口嵌套的内部接口        </span><br>        OuterInterface2.<span class="hljs-type">InnerInterface</span> <span class="hljs-variable">innerInterface1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterInterface2</span>.InnerInterfaceImp();   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></div></figure><h2 id="外部-类-接口-访问其内部-类-接口"><a href="#外部-类-接口-访问其内部-类-接口" class="headerlink" title="外部[类/接口]访问其内部[类/接口]"></a>外部[类/接口]访问其内部[类/接口]</h2><p><strong>都可访问</strong>，即使是private, 因为private是当前类可见，<strong>对于内部类来说，其当前类就是其外部类</strong></p><h2 id="内部-类-接口-访问其外部-类-接口"><a href="#内部-类-接口-访问其外部-类-接口" class="headerlink" title="内部[类/接口]访问其外部[类/接口]"></a>内部[类/接口]访问其外部[类/接口]</h2><p><strong>对外部类/接口的访问</strong>：创建实例、使用方法、使用变量</p><h3 id="内部类访问外部类"><a href="#内部类访问外部类" class="headerlink" title="内部类访问外部类"></a>内部类访问外部类</h3><p><strong>类比静态方法</strong><br><strong>静态内部类</strong>：可以创建<strong>外部类实例（其他类也可以创建）</strong>，但是不能直接使用外部类的<strong>变量、方法、其他内部类</strong>，因为它是静态的，<strong>没有外部类实例的引用</strong>，<strong>就像静态方法不能使用非静态变量</strong>一样。<br><img src="/categories/web/java/Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%88%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3%EF%BC%89/1.png" alt="1"></p><p><strong>非静态内部类</strong>：都可以访问<br><img src="/categories/web/java/Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%88%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3%EF%BC%89/2.png" alt="2"></p><h3 id="内部类访问外部接口"><a href="#内部类访问外部接口" class="headerlink" title="内部类访问外部接口"></a>内部类访问外部接口</h3><p><strong>接口中的内部类是隐式public static的</strong>，不能为private<br>参考静态内部类访问外部类</p><h3 id="内部接口访问外部类"><a href="#内部接口访问外部类" class="headerlink" title="内部接口访问外部类"></a>内部接口访问外部类</h3><p>需通过内部接口的实现类（可以为内部类）访问外部类<br>参考内部类访问外部类</p><h3 id="内部接口访问外部接口"><a href="#内部接口访问外部接口" class="headerlink" title="内部接口访问外部接口"></a>内部接口访问外部接口</h3><p>需通过内部接口的实现类访问外部接口<br><strong>接口中的内部接口是隐式public static的</strong>，不能为private<br>参考静态内部类访问外部类</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内部类、内部接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http与https协议</title>
    <link href="/categories/web/default/http%E4%B8%8Ehttps%E5%8D%8F%E8%AE%AE.html"/>
    <url>/categories/web/default/http%E4%B8%8Ehttps%E5%8D%8F%E8%AE%AE.html</url>
    
    <content type="html"><![CDATA[<h1 id="http-amp-https协议"><a href="#http-amp-https协议" class="headerlink" title="http&amp;https协议"></a>http&amp;https协议</h1><p>参考博客：</p><ul><li><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">HTTP和HTTPS协议，看一篇就够了</a></li></ul><h2 id="什么是http"><a href="#什么是http" class="headerlink" title="什么是http"></a>什么是http</h2><p>超文本传输协议，是一个基于请求与响应，<strong>无状态的</strong>，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p><ul><li><strong>默认端口80， 如果 一台主机上有多个服务器呢?</strong><h2 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h2></li></ul><p>http的请求报文由：请求行、首部、空行、主体四个部分组成。<br>其中请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔<br><img src="http%E4%B8%8Ehttps%E5%8D%8F%E8%AE%AE/1.png" alt="报文格式"></p><h2 id="http通信流程"><a href="#http通信流程" class="headerlink" title="http通信流程"></a>http通信流程</h2><p>web客户端tcp连接到Web服务器-&gt;发送Http请求-&gt;服务器接受请求并返回HTTP响应-&gt;释放连接TCP连接-&gt;客户端浏览器解析HTML内容</p><pre><code class=" mermaid">graph TDA(web客户端tcp连接到Web服务器) --&gt;B(发送Http请求)B --&gt;C(服务器接受请求并返回HTTP响应)C--&gt;D(释放连接TCP连接)D--&gt;E(客户端浏览器解析HTML内容)</code></pre><p><img src="http%E4%B8%8Ehttps%E5%8D%8F%E8%AE%AE/2.png" alt="http通信流程"></p><h2 id="什么是https"><a href="#什么是https" class="headerlink" title="什么是https"></a>什么是https</h2><blockquote><p>图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，<strong>经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包</strong>。<strong>HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性</strong>。PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p></blockquote><h2 id="成本考虑"><a href="#成本考虑" class="headerlink" title="成本考虑"></a>成本考虑</h2><ul><li>SSL证书需要购买申请，功能越强大的证书费用越高</li><li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</li><li>根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。</li><li>HTTPS连接缓存不如HTTP高效，流量成本高。</li><li>HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。</li><li>HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>default</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie/session机制(持续更新)</title>
    <link href="/categories/web/default/cookie-session%E6%9C%BA%E5%88%B6.html"/>
    <url>/categories/web/default/cookie-session%E6%9C%BA%E5%88%B6.html</url>
    
    <content type="html"><![CDATA[<p>参考博客：</p><ul><li><a href="https://www.cnblogs.com/l199616j/p/11195667.html">cookie和session的详解与区别 </a></li></ul><p>　会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。<strong>常用的会话跟踪技术是Cookie与Session</strong>：</p><ul><li>Cookie通过在客户端记录信息确定用户身份。</li><li>Session通过在服务器端记录信息确定用户身份。</li><li>什么时候不能用Cookie，什么时候不能用Session。<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="为什么使用cookie"><a href="#为什么使用cookie" class="headerlink" title="为什么使用cookie"></a>为什么使用cookie</h3></li><li>HTTP协议是<strong>无状态</strong>的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。<h3 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h3></li><li>cookie是一种记录客户状态的机制</li><li>给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</li><li>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。<h3 id="cookie特性"><a href="#cookie特性" class="headerlink" title="cookie特性"></a>cookie特性</h3></li></ul><p>Cookie具有不可跨域名性<br>域名<br>路径<br>安全属性</p><h3 id="cookie案例：永久登录"><a href="#cookie案例：永久登录" class="headerlink" title="cookie案例：永久登录"></a>cookie案例：永久登录</h3><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><h3 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h3><ul><li><p>Session是另一种记录客户状态的机制。</p></li><li><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是Session。</p></li><li><p>Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p></li><li><p>客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><h3 id="session如何判别是否为同一用户"><a href="#session如何判别是否为同一用户" class="headerlink" title="session如何判别是否为同一用户"></a>session如何判别是否为同一用户</h3></li><li><p>虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然<strong>需要客户端浏览器的支持</strong>。这是因为<strong>Session需要使用Cookie作为识别标志</strong>。</p></li><li><p><strong>HTTP协议是无状态的</strong>，Session不能依据HTTP连接来判断是否为同一客户</p></li><li><p>因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。</p></li><li><p>该Cookie为<strong>服务器自动生成</strong>的，它的maxAge属性一般为–1，表示<strong>仅当前浏览器内有效</strong>，并且<strong>各浏览器窗口间不共享</strong>，<strong>关闭浏览器就会失效</strong>。</p></li><li><p>因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的Session。但是由浏览器窗口内的链接、脚本等打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外。这类子窗口会共享父窗口的Cookie，因此会共享一个Session。</p></li></ul><p>注意：新开的浏览器窗口会生成新的Session，但子窗口除外。子窗口会共用父窗口的Session。例如，在链接上右击，在弹出的快捷菜单中选择“在新窗口中打开”时，子窗口便可以访问父窗口的Session。　　<br>如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。</p><h3 id="cookie与session不同点"><a href="#cookie与session不同点" class="headerlink" title="cookie与session不同点"></a>cookie与session不同点</h3><ul><li>Cookie保存在客户端浏览器中。Cookie机制是通过检查客户身上的“通行证”来确定客户身份。</li><li>Session保存在服务器上。Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。</li></ul><h3 id="session特性"><a href="#session特性" class="headerlink" title="session特性"></a>session特性</h3><p>生命周期<br>有效期</p><h3 id="session案例"><a href="#session案例" class="headerlink" title="session案例"></a>session案例</h3><h3 id="URL地址重写"><a href="#URL地址重写" class="headerlink" title="URL地址重写"></a>URL地址重写</h3>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>default</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cookie</tag>
      
      <tag>session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http请求返回状态码</title>
    <link href="/categories/web/default/http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81.html"/>
    <url>/categories/web/default/http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81.html</url>
    
    <content type="html"><![CDATA[<p>参考博客：</p><ul><li><a href="https://blog.csdn.net/wangsen2235068/article/details/8081274">HTTP请求返回状态码详解</a></li><li><a href="https://blog.csdn.net/beyond150/article/details/102128827">常用的HTTP状态码(面试中常问到…)</a></li></ul><h2 id="首先，什么是状态码？"><a href="#首先，什么是状态码？" class="headerlink" title="首先，什么是状态码？"></a>首先，什么是状态码？</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结<br>果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出<br>现了错误。</p><h2 id="接着来，状态码有哪些种类？"><a href="#接着来，状态码有哪些种类？" class="headerlink" title="接着来，状态码有哪些种类？"></a>接着来，状态码有哪些种类？</h2><p><img src="http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81/1.png" alt="状态码"><br>接下来我们详细说一说常用的状态码（背吧，别犹豫）</p><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><p>200 ok（请求成功）<br>204 no content （请求成功，但是没有结果返回）<br>206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）?</p><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><p>301 move permanently （永久性重定向）<br>302 found （临时性重定向）<br>303 see other （示由于请求对应的资源存在着另一个 URI，应使用 GET<br>方法定向获取请求的资源）<br>304 not modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关）<br>307 temporary redirect （跟302一个意思）</p><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><p>400 bad request （请求报文存在语法错误）<br>401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））<br>403 forbidden （请求被服务器拒绝了）<br>404 not found （服务器上无法找到请求的资源）</p><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><p>500 internal server error （服务端执行请求时发生了错误）<br>503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>default</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http请求类型</title>
    <link href="/categories/web/default/http%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B.html"/>
    <url>/categories/web/default/http%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<p>参考博客:</p><ul><li><p><a href="https://blog.csdn.net/u012813201/article/details/70210812">HTTP请求的几种类型</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42981419/article/details/86162244">HTTP请求方式中8种请求方法（简单介绍)</a></p><h2 id="http报文格式-重要"><a href="#http报文格式-重要" class="headerlink" title="http报文格式(重要)"></a>http报文格式(重要)</h2></li><li><p>http的请求报文由：请求行、<strong>首部</strong>、空行、主体(请求数据)四个部分组成。其中请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔</p></li><li><p>一个响应由状态行、响应头部、空行和响应数据4部分组成。<br><img src="http%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B/1.png" alt="报文格式"></p></li></ul><h3 id="请求头和响应头"><a href="#请求头和响应头" class="headerlink" title="请求头和响应头"></a>请求头和响应头</h3><ul><li><a href="https://blog.csdn.net/kfanning/article/details/6062118">HTTP请求头详解</a></li></ul><p>首部，消息报头，用来<strong>说明客户端要使用的一些附加信息</strong></p><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>下面是一些最常见的请求头：   <br><strong>Accept：</strong> 浏览器可接受的MIME类型。</p><blockquote><p>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。</p></blockquote><p><strong>Accept - Charset：</strong> 浏览器可接受的字符集。<br><strong>Accept - Encoding：</strong> 浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。<br><strong>Accept - Language：</strong> 浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。<br><strong>Authorization：</strong> 授权信息，通常出现在对服务器发送的WWW - Authenticate头的应答中。<br><strong>Connection：</strong> 表示是否需要持久连接。如果Servlet看到这里的值为“Keep - Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content - Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。<br><strong>Content - Length：</strong> 表示请求消息正文的长度。<br><strong>Cookie：</strong> 这是最重要的请求头信息之一，参见后面《Cookie处理》一章中的讨论。<br><strong>From：</strong> 请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。<br><strong>Host：</strong> 初始URL中的主机和端口。<br><strong>If - Modified - Since：</strong> 只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。<br><strong>Pragma：</strong> 指定“no - cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。<br><strong>Referer：</strong> 包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。<br><strong>User - Agent：</strong> 浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。<br><strong>UA - Pixels，UA - Color，UA - OS，UA - CPU：</strong> 由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p><blockquote><p><a href="http://www.baidu.com的GET请求如下所示：">www.baidu.com的GET请求如下所示：</a></p><p>GET / HTTP/1.1<br>Host: <a href="http://www.baidu.comuser-agent/">www.baidu.comUser-Agent</a>: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>Gecko/20050225 Firefox/1.0.1<br>Connection: Keep-Alive</p><ul><li>请求行<ul><li>第一部分说明了该请求是GET请求。</li><li>该行的第二部分是一个斜杠（/），用来说明请求的是该域名的根目录。</li><li>该行的最后一部分说明使用的是HTTP 1.1版本（另一个可选项是1.0）。</li></ul></li><li>第2行是请求的第一个首部，HOST。首部HOST将指出请求的目的地。结合HOST和上一行中的斜杠（/），可以通知服务器请求的是<a href="http://www.baidu.com/%EF%BC%88HTTP">www.baidu.com/（HTTP</a> 1.1才需要使用首部HOST，而原来的1.0版本则不需要使用）。</li><li>第3行中包含的是首部User-Agent，服务器端和客户端脚本都能够访问它，它是浏览器类型检测逻辑的重要基础。该信息由你使用的浏览器来定义（在本例中是Firefox 1.0.1），并且在每个请求中将自动发送。</li><li>最后一行是首部Connection，通常将浏览器操作设置为Keep-Alive（当然也可以设置为其他值）。</li><li>注意，在最后一个首部之后有一个空行。即使不存在请求主体，这个空行也是必需的。</li></ul></blockquote><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>例子：访问谷歌：<a href="http://www.google.cn/search">www.google.cn/search</a></p><figure class="highlight apache"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-8givvhlax5lwsb"></i><span>apache</span><div class="collapse" id="collapse-8givvhlax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> /search HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span>  <br><span class="hljs-attribute">Accept</span>: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, <br><span class="hljs-attribute">application</span>/msword, application/x-silverlight, application/x-shockwave-flash, */*  <br><span class="hljs-attribute">Referer</span>: &lt;a href=<span class="hljs-string">&quot;http://www.google.cn/&quot;</span>&gt;http://www.google.cn/&lt;/a&gt;  <br><span class="hljs-attribute">Accept</span>-Language: zh-cn  <br><span class="hljs-attribute">Accept</span>-Encoding: gzip, deflate  <br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">4</span>.<span class="hljs-number">0</span> (compatible; MSIE <span class="hljs-number">6</span>.<span class="hljs-number">0</span>; Windows NT <span class="hljs-number">5</span>.<span class="hljs-number">1</span>; SV1; .NET CLR <span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">50727</span>; TheWorld)  <br><span class="hljs-attribute">Host</span>: &lt;a href=<span class="hljs-string">&quot;http://www.google.cn&quot;</span>&gt;www.google.cn&lt;/a&gt;  <br><span class="hljs-attribute">Connection</span>: Keep-Alive  <br><span class="hljs-attribute">Cookie</span>: PREF=ID=<span class="hljs-number">80</span>a06da87be9ae3c:U=f7167333e2c3b714:NW=<span class="hljs-number">1</span>:TM=<span class="hljs-number">1261551909</span>:LM=<span class="hljs-number">1261551917</span>:S=ybYcq2wpfefs4V9g; <br><span class="hljs-attribute">NID</span>=<span class="hljs-number">31</span>=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-<span class="hljs-number">2</span>hfBW7bUFwVh7pGaRUb0RnHcJU37y-<br><span class="hljs-attribute">FxlRugatx63JLv7CWMD6UB_O_r</span>  <br> <br><span class="hljs-attribute">hl</span>=zh-CN&amp;source=hp&amp;q=domety<br></code></pre></td></tr></table></div></figure><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><figure class="highlight xquery"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-l7yeo6lax5lwsb"></i><span>xquery</span><div class="collapse" id="collapse-l7yeo6lax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>Date: Fri, <span class="hljs-number">22</span> May <span class="hljs-number">2009</span> <span class="hljs-number">06</span>:<span class="hljs-number">07</span>:<span class="hljs-number">21</span> GMT<br>Content-Type: <span class="hljs-type">text</span>/html; charset=UTF-<span class="hljs-number">8</span><br> <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">      </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"> </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-comment">&lt;!--body goes here--&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"> </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></div></figure><h2 id="8种请求方法"><a href="#8种请求方法" class="headerlink" title="8种请求方法"></a>8种请求方法</h2><p><img src="http%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B/2.png" alt="8中请求"></p><p>HTTP请求的方法：</p><ul><li>HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式</li><li>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</li><li>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法</li></ul><h3 id="1-GET"><a href="#1-GET" class="headerlink" title="1. GET"></a>1. GET</h3><p>向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。</p><h3 id="2-HEAD"><a href="#2-HEAD" class="headerlink" title="2. HEAD"></a>2. HEAD</h3><p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p><h3 id="3-POST"><a href="#3-POST" class="headerlink" title="3. POST"></a>3. POST</h3><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 </p><h4 id="get与post区别"><a href="#get与post区别" class="headerlink" title="get与post区别"></a>get与post区别</h4><p>POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开, POST方式大多用于页面的表单中。</p><ul><li><p>1.数据存放位置：</p><ul><li><p><strong>GET</strong>：请求的<strong>数据会附在URL之后</strong>（就是把数据放置在HTTP协议头＜request-line＞中），以?分割URL和传输数据，多个参数用&amp;连接;例如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。  </p></li><li><p><strong>POST</strong>：把提交的<strong>数据放置在是HTTP包的包体</strong>＜request-body＞中。<strong>GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。</strong></p></li></ul></li><li><p>2.传输数据的大小：  </p><ul><li> 首先声明,<strong>HTTP协议没有对传输的数据大小进行限制</strong>，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：   </li><li><strong>GET</strong>: <strong>特定浏览器和服务器对URL长度有限制</strong>，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。   因此对于GET提交时，传输数据就会受到URL长度的限制。   </li><li><strong>POST</strong>: 由于不是通过URL传值，<strong>理论上数据不受限</strong>。但<strong>实际各个WEB服务器会规定对post提交数据大小进行限制</strong>，Apache、IIS6都有各自的配置。</li></ul></li><li><p> 3.安全性：    </p><ul><li> POST的安全性要比GET的安全性高。</li><li> 通过GET提交数据，用户名和密码将明文出现在URL上，(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录。<h3 id="4-PUT"><a href="#4-PUT" class="headerlink" title="4. PUT"></a>4. PUT</h3>向指定资源位置上传其最新内容<h3 id="5-DELETE"><a href="#5-DELETE" class="headerlink" title="5. DELETE"></a>5. DELETE</h3>请求服务器删除Request-URL所标识的资源</li></ul></li></ul><h3 id="6-CONNECT"><a href="#6-CONNECT" class="headerlink" title="6. CONNECT"></a>6. CONNECT</h3><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><h3 id="7-OPTIONS"><a href="#7-OPTIONS" class="headerlink" title="7. OPTIONS"></a>7. OPTIONS</h3><p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p><h3 id="8-TRACE"><a href="#8-TRACE" class="headerlink" title="8. TRACE"></a>8. TRACE</h3><p>回显服务器收到的请求，主要用于测试或诊断</p><h2 id="URI-amp-RUL"><a href="#URI-amp-RUL" class="headerlink" title="URI&amp;RUL"></a>URI&amp;RUL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><ul><li>URI：Uniform Resource Identifier 统一资源标识符, 是用来标示 一个具体的资源的，我们可以通过 URI 知道一个资源是什么</li><li>URL：Uniform Resource Location 统一资源定位符，是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>default</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于快排partition求第k大数</title>
    <link href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%9F%BA%E4%BA%8E%E5%BF%AB%E6%8E%92partition%E6%B1%82%E7%AC%ACk%E5%A4%A7%E6%95%B0.html"/>
    <url>/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%9F%BA%E4%BA%8E%E5%BF%AB%E6%8E%92partition%E6%B1%82%E7%AC%ACk%E5%A4%A7%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<p>参考博客：<br><a href="https://blog.csdn.net/orangefly0214/article/details/86527462">面试题：从 n 个数中找出第 K 大的数</a></p><h2 id="适合海量数据的-o-nlogk-的方法"><a href="#适合海量数据的-o-nlogk-的方法" class="headerlink" title="适合海量数据的 o(nlogk)的方法"></a>适合海量数据的 o(nlogk)的方法</h2><p>借助外部数据结构（最小堆），也可以不借助外部的数据结构，手动实现一个最小堆。<br>堆中最多 k 个元素，扫描数组 O(n), 每次向堆中插入元素，删除元素，保持堆中元素是当前最大的 k 的数字。更新堆时间 logk, 总时间 nlogk</p><h2 id="基于快速排序的-partion-方法，时间复杂度为-o-n"><a href="#基于快速排序的-partion-方法，时间复杂度为-o-n" class="headerlink" title="基于快速排序的 partion 方法，时间复杂度为 o(n)"></a>基于快速排序的 partion 方法，时间复杂度为 o(n)</h2><h3 id="快排中-partion"><a href="#快排中-partion" class="headerlink" title="快排中 partion"></a><a href="https://blog.csdn.net/Meloor/article/details/88313735">快排</a>中 partion</h3><ul><li>以从大到小排为例, 数组为 a[]</li><li>首先选择一个基准数，这里以最右边的数为例。</li><li>从最左边开始找，只要大于基准数就把它交换到前面。</li><li>这样共<strong>比较了 n 次</strong>，假设这里交换到前面的数有 i 个，那么 a[i]就是基准数存放的位置。</li><li>然后<strong>以基准数为分界线</strong>把需要排序的数组分为左右两部分。</li><li>继续对子数组进行分割，直到其长度为 1。</li></ul><h3 id="paritition-求第-k-大"><a href="#paritition-求第-k-大" class="headerlink" title="paritition 求第 k 大"></a>paritition 求第 k 大</h3><p>part1:</p><ul><li>以从大到小排为例, 数组为 a[]</li><li>首先选择一个基准数，这里以最右边的数为例。</li><li>从最左边开始找，只要大于基准数就把它交换到前面。</li><li>这样共<strong>比较了 O(n)次</strong>，假设这里交换到前面的数有 i 个，那么 a[i]就是基准数存放的位置。</li><li>然后<strong>以基准数为分界线</strong>把需要排序的数组分为左右两部分。</li></ul><p>part2:</p><ul><li>如果 i==k-1 ,那么 a[i]就是数组的第 k 大数；</li><li>否则, 通过判断下标，只计算包含了索引为 k-1 的那一半，再次 partition</li></ul><h3 id="例子：-6-7-4-5-2-1-3-求第-2-大数"><a href="#例子：-6-7-4-5-2-1-3-求第-2-大数" class="headerlink" title="例子：[6,7,4,5,2,1,3]求第 2 大数"></a>例子：[6,7,4,5,2,1,3]求第 2 大数</h3><p>目标位置：k-1=1</p><ul><li>初始数组 <strong>[6,7,4,5,2,1,3]</strong></li><li>第一轮 partition, 以 3 为基准点，[6,7,4,5,3,1,2], i=4&gt;1, 继续 partition 包含索引为 1 的那一部分 <strong>[6,7,4,5]</strong></li><li>第二轮 partition, 以 5 为基准点，[6,7,5,4], i=2&gt;1, 继续 partion <strong>[6,7]</strong></li><li>第三轮 partition, 以 7 为基准点，[7,6], i=0&lt;1, 继续 partion <strong>[6]</strong></li><li>6 即为所求的第 2 大数</li></ul><h3 id="时间复杂度为-O-n"><a href="#时间复杂度为-O-n" class="headerlink" title="时间复杂度为 O(n)"></a>时间复杂度为 O(n)</h3><ul><li><p>快排，每次划分将数组一分为二，且花费 n 的时间（第二轮要 partition 两次，加起来为 n…），最多划分 logn 次, 总时间 O(nlogn)</p></li><li><p>partition 求第 k 大，第一次划分为 n，第二次划分为 n/2，…, 最多划分 logn 次，总和小于 2n</p><ul><li>如 n=8, s=8+4+2+1=15&lt;16</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快排</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前后端分离架构</title>
    <link href="/categories/web/default/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84.html"/>
    <url>/categories/web/default/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84.html</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://www.zhihu.com/answer/547205270">到底什么是前后端分离 1</a><br><a href="https://www.zhihu.com/answer/557406666">到底什么是前后端分离 2</a><br><a href="https://www.zhihu.com/answer/542961677">到底什么是前后端分离 3</a></p><p>前后端分离是个<strong>架构设计问题</strong>。所谓架构设计，实际上是如何合理的对现实的人力架构进行系统映射，以便最大限度的提高整个公司的运行效率。</p><h2 id="前后端的定义"><a href="#前后端的定义" class="headerlink" title="前后端的定义"></a>前后端的定义</h2><p>前后端定义，不应该是以语言来定义，而是应该以它的<strong>运行环境</strong></p><ul><li>Html+CSS+JS，都是<strong>在浏览器端执行，统一称之为前端</strong>。(用户能看到)</li><li>Java，C，Python，PHP 这些<strong>在服务器端运行，统一称之为后端</strong>。(用户看不到）</li></ul><h2 id="前后端不分离"><a href="#前后端不分离" class="headerlink" title="前后端不分离"></a>前后端不分离</h2><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="/categories/web/default/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84/1.png" alt="图片"></p><h3 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h3><p>浏览器发请求，服务器端给出一个完整的网页，浏览器再发请求，服务器端再给出一个完整的网页<br><img src="/categories/web/default/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84/3.png" alt="图片"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>传输的重复数据比较多，网络又会有延迟。所以有没有办法，只传送必要的数据？这是 Ajax 的起源。</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>Ajax 就是只传递数据，不传递整个网页。这也是被用来在翻页，注册，发送验证码等场景，但也仅仅止布于此了。</p><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><h3 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="/categories/web/default/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84/2.png" alt="图片"></p><h3 id="交互方式-通过浏览器测试"><a href="#交互方式-通过浏览器测试" class="headerlink" title="交互方式(通过浏览器测试)"></a>交互方式(通过浏览器测试)</h3><ul><li>页面跳转(浏览器地址栏 url 会变)时浏览器先发送请求给前端服务器</li><li>浏览器得到响应数据前端代码(html+css+js, 响应数据)并渲染。(地址栏输入后端服务器的 url 会直接显示 json 格式数据, 是 html 就会渲染)</li><li>渲染时会执行 js 代码，这时 js 代码向后端服务器发送请求得到数据并动态更新 html 元素得到最终页面。<br><img src="/categories/web/default/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84/4.png" alt="图片"></li></ul><h3 id="区分前后端的原因"><a href="#区分前后端的原因" class="headerlink" title="区分前后端的原因"></a>区分前后端的原因</h3><ul><li><p>第一个，是可以并行开发。前后端的进度互不影响，在过去，前后端不分离的情况下，前端的工作量相对较少，一个前端可以对四个后端。</p></li><li><p>第二个，是成本问题。在过去，后端的成本还是比前端要高一些。同样的工作，如果能拆给两个人做，一个成本高一点，一个成本低一点，能接受。</p></li><li><p>第三个，CSS 太难了。JS 还好，和后端语言在对技能的训练上相差不大，可是。。CSS 是什么鬼？记住那么多的属性，和 Hash 算法有关系吗？</p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>前端人员和后端人员只需约定好接口，大大降低了前后端耦合性</li><li>前端人员彻底不用再关心业务处理是怎么回事，他只需要把界面做好就可以了</li><li>后端人员也不用再关系前端界面是什么样的，他只需要做好业务逻辑处理即可。</li><li>服务的切离，代码管理，服务部署也都独立出来分别管理，系统的灵活性也获得了极大的提升。</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>default</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前后端分离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库索引</title>
    <link href="/categories/web/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.html"/>
    <url>/categories/web/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.html</url>
    
    <content type="html"><![CDATA[<p>参考博客：</p><ul><li><a href="https://blog.csdn.net/lnazj/article/details/90762470">数据库索引原理</a></li><li><a href="https://blog.csdn.net/gaotiedun1/article/details/88584362">五种索引类型</a></li><li><a href="https://blog.csdn.net/calledWWW/article/details/79371040">什么是数据库索引，是怎么工作的</a> (好文推荐)</li></ul><p>前面有看不懂的地方可以跳过先看原理。</p><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引是一种数据结构。为了加速对表中数据行的检索而创建的。</p><h2 id="作用-优点"><a href="#作用-优点" class="headerlink" title="作用(优点)"></a>作用(优点)</h2><p>使用索引的全部意义就是通过减少一张表中需要查询的记录/行的数目来加快搜索的速度</p><ul><li>大大加快数据的检索速度;</li><li>创建唯一性索引，保证数据库表中每一行数据的唯一性;</li><li>加速表和表之间的连接; (查询列中的某个值变快了，B+树索引:n-&gt;logn)</li><li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。 (查询列中的某个值变快了，B+树索引:n-&gt;logn, 分组时根据某个值相同进行分组， 一般来说使用 B+树索引，其值是排好序的，所以使用排序子句更快)</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>索引需要占用数据表以外的物理存储空间。(索引本质是数据结构，常用的如 MySQL 中的 B+树)</li><li>降低了数据的维护速度，创建索引和维护索引要花费一定的时间。(创建树，向树中插入值或修改值)</li><li>当对表的数据进行 <strong>INSERT,UPDATE,DELETE</strong> 的时候,索引也要动态的维护,这样就会<strong>降低数据的维护速度</strong>,(<strong>建立索引会占用磁盘空间的索引文件</strong>。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>索引是一种数据结构，存储的是表中某一列的值。有 B+树索引、哈希（散列）索引、bitmap(位图)索引、R-tree 等数据结构</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>mysql 中 innodb 索引(MySQL 的默认存储引擎)，采用的就是是<a href="https://blog.csdn.net/lnazj/article/details/90762470">B+树数据结构</a>。</p><ul><li>这是一个多路平衡树，相比较平衡二叉树，它利用<strong>多个分支的结点</strong>，减少获取记录时所经历的结点数，从而达到节省存取时间的目的。</li><li>(硬盘中的结点也是 B-tree 结构的。与内存相比，硬盘必须花成倍的时间来存取一个数据元素，这是因为硬盘的机械部件读写数据的速度远远赶不上纯电子媒体的内存。)</li><li>查询、插入、修改时间为 logn, n 为节点个数</li></ul><h3 id="哈希表索引"><a href="#哈希表索引" class="headerlink" title="哈希表索引"></a>哈希表索引</h3><p>将列的值通过 hash 算法计算出 hash 值，将其作为索引的键值（key），和键值相对应实际的值（value）是指向该表中相应行的指针。即（hash 值，指针）, 类似于 map。<br><strong>哈希索引缺点:</strong> 哈希表是无序的数据结构,只适合查询键值对, 也就是说查询相等的查询</p><h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><ul><li>R-Tree 作为索引, 通常用来为空间问题提供帮助。例如，一个查询要求“查询出所有距离我两公里之内的星巴克”，如果数据库表使用 R- Tree 索引，这类查询的效率将会提高。</li><li>位图索引（bitmap index）， 这类索引适合放在包含布尔值(true 和 false)的列上，但是这些值（表示 true 或 false 的值）的许多实例-基本上都是选择性（selectivity）低的列。</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>表中某列在查询过程中使用的非常频繁，那就在该列上创建索引。</li></ul><h2 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h2><ul><li>查询中很少使用到的列 不应该创建索引</li><li><strong>很少数据的列也不应该建立索引?</strong></li><li>定义为 text 和 image 和 bit 数据类型的列不应该增加索引?</li><li>当表的修改(UPDATE,INSERT,DELETE)操作<strong>远远大于</strong>检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系</li></ul><h2 id="索引的原则-看不太懂"><a href="#索引的原则-看不太懂" class="headerlink" title="索引的原则(看不太懂)"></a>索引的原则(看不太懂)</h2><p><a href="https://blog.csdn.net/lnazj/article/details/90762470">数据库索引原理</a></p><ul><li>5.1 离散性越高越好</li><li>5.2 最左匹配原则对索引中关键字进行计算（对比），一定是从左往右依次进行，且不可跳过</li><li>5.3 索引列的数据长度能少则少</li><li>5.4 匹配列前缀可用到索引 like %9999%、like %9999 用不到索引；</li><li>5.5 Where 条件中 not in 和 &lt;&gt;操作无法使用索引</li><li>5.6 多用指定列查询，只返回自己想到的数据列，少用 select * ,这样有可能用到覆盖索引；</li><li>5.7 索引上不加计算</li></ul><h2 id="数据库怎么知道什么时候使用索引"><a href="#数据库怎么知道什么时候使用索引" class="headerlink" title="数据库怎么知道什么时候使用索引"></a>数据库怎么知道什么时候使用索引</h2><p>当这个 SQL （SELECT * FROM Employee WHERE Employee_Name = ‘Jesus’ ）运行时，数据库会检查在查询的列上是否有索引。假设 Employee_Name 列上确实创建了索引，数据库会接着检<strong>查使用这个索引做查询是否合理</strong> - 因为有些场景下，使用索引比起全表扫描会更加低效。</p><h2 id="五种索引类型-待补充"><a href="#五种索引类型-待补充" class="headerlink" title="五种索引类型(待补充)"></a>五种索引类型(待补充)</h2><p>单列索引(主键索引,唯索引,普通索引)和组合索引</p><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引?"></a>组合索引?</h3><p>,<strong>原理?</strong>(nickname_account_createdTime_Index) 那么他实际包含的是 3 个索引 (nickname) (nickname,account)(nickname,account,created_time)</p><p>在使用查询的时候遵循 mysql 组合索引的 <strong>“最左前缀”?</strong></p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p><strong>文本字段</strong>上(text)如果建立的是普通索引,那么只有对文本的字段内容前面的字符进行索引,其字符大小根据索引建立索引时申明的大小来规定.如果文本中出现多个一样的字符,而且需要查找的话,那么其条件只能是 where column lick ‘%xxxx%’ 这样做会让索引失效.这个时候全文索引就祈祷了作用了</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>B+树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务</title>
    <link href="/categories/web/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BA%8B%E5%8A%A1.html"/>
    <url>/categories/web/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BA%8B%E5%8A%A1.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/w_linux/article/details/79666086">参考博客</a>讲的非常清楚，下面是补充的笔记</p><h2 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h2><p>事务(Transsction)</p><ul><li>事务：<strong>一个最小的不可再分的工作单元</strong>；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)</li><li>一个完整的业务需要批量的 DML(insert、update、delete)语句共同联合完成 <strong>(也有说法包含 selecet?)</strong></li><li>事务只和 DML 语句有关，或者说<strong>DML 语句才有事务</strong>。这个和业务逻辑有关，业务逻辑不同，DML 语句的个数不同</li></ul><ul><li>DDL：<br>数据库模式定义语言 DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。主要由 create（添加）、alter（修改）、drop（删除）和 truncate（删除）  四个关键字完成。</li><li>DML(Data Manipulation Language)数据操纵语言命令使用户能够查询数据库以及操作已有数据库中的数据。　　如 insert,delete,update,select(插入、删除、修改、检索)等都是 DML.</li></ul><h2 id="事务四大特征-ACID"><a href="#事务四大特征-ACID" class="headerlink" title="事务四大特征(ACID)"></a>事务四大特征(ACID)</h2><p>它这里原子性和一致性讲错了，下面为更正过的：<br><a href="https://blog.csdn.net/liuskyter/article/details/81948310">参考博客</a></p><ul><li><p><strong>原子性(A)</strong> ：<br>原子性是指事务包含的所有操作<strong>要么全部成功，要么全部失败回滚</strong>，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p></li><li><p><strong>一致性(C)</strong> ：<br>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务<strong>执行之前和执行之后都必须处于一致性状态</strong>。</p><blockquote><p>拿 <strong>转账</strong> 来说，假设用户甲和用户乙两者的钱加起来一共是 5000，那么不管甲和乙之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。</p></blockquote></li><li><p><strong>隔离性(I)</strong> ：事务 A 和事务 B 之间具有隔离性, <strong>隔离级别</strong> 有四个：</p><ul><li>读未提交：read uncommitted</li><li>读已提交：read committed</li><li>可重复读：repeatable read</li><li>串行化：serializable<ul><li>吞吐量太低，用户体验差，事务串行，而不是并发</li></ul></li><li>看下面这两篇，讲的非常好</li><li><a href="https://blog.csdn.net/qq_33591903/article/details/81672260">快速理解脏读、不可重复读、幻读</a></li><li><a href="https://blog.csdn.net/qq_33591903/article/details/82079302">事务隔离级别</a></li></ul></li><li><p><strong>持久性(D)</strong> ：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)</p></li><li><p><strong>在我的理解中，原子性、隔离性、持久性都是为了保障一致性而存在的，一致性也是最终的目的</strong></p></li></ul><h2 id="事务与数据库底层数据"><a href="#事务与数据库底层数据" class="headerlink" title="事务与数据库底层数据"></a>事务与数据库底层数据</h2><p>在事物进行过程中，未结束之前，DML 语句是不会更改底层数据，<strong>只是将历史操作记录一下，在内存中完成记录</strong>。只有在事物结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据</p><h2 id="提交与回滚"><a href="#提交与回滚" class="headerlink" title="提交与回滚"></a>提交与回滚</h2><ul><li>在 MySQL 中，默认情况下，事务是自动提交的，也就是说，只要执行一条 DML 语句就开启了事物，并且提交了事务</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitee+hexo搭建个人博客</title>
    <link href="/categories/web/front-end/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html"/>
    <url>/categories/web/front-end/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    
    <content type="html"><![CDATA[<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.jianshu.com/p/7c013faaaba1">如何利用好Github pages</a>  </p><h2 id="jekyll-的不足"><a href="#jekyll-的不足" class="headerlink" title="jekyll 的不足"></a>jekyll 的不足</h2><ul><li>gitee 上使用 jekyll 效果完全和 Github 上不同，必须要在本地环境编译再 push, 而 github 自带 jekyll 引擎，可以直接在 github 原码上直接修改</li><li><a href="https://www.cnblogs.com/FLY_DREAM/p/13669729.html">https://www.cnblogs.com/FLY_DREAM/p/13669729.html</a></li></ul><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><ul><li>教程<a href="https://www.cnblogs.com/yizhixue-hx/p/12638361.html">https://www.cnblogs.com/yizhixue-hx/p/12638361.html</a></li></ul><h3 id="hexo-init-卡住"><a href="#hexo-init-卡住" class="headerlink" title="hexo init 卡住"></a>hexo init 卡住</h3><p><a href="https://www.jianshu.com/p/a409601734f1">https://www.jianshu.com/p/a409601734f1</a></p><!-- ![图片](gitee-hexo搭建个人博客/1.png) --><p><img src="/categories/web/front-end/gitee+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png" alt="图片"></p><figure class="highlight csharp"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-tbsmjklax5lwsb"></i><span>csharp</span><div class="collapse" id="collapse-tbsmjklax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span> blog<br></code></pre></td></tr></table></div></figure><p>换成, (下面 npm 换成 cnpm 更快)</p><figure class="highlight awk"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-6klcxulax5lwsb"></i><span>awk</span><div class="collapse" id="collapse-6klcxulax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone --depth <span class="hljs-number">1</span> https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/weilining/</span>hexo-starter.git blog<br>cd blog<br>git submodule init<br>git submodule update<br>cnpm config set registry http:<span class="hljs-regexp">//</span>registry.npm.taobao.org<br>cnpm i<br></code></pre></td></tr></table></div></figure><h3 id="hexo-插入图片"><a href="#hexo-插入图片" class="headerlink" title="hexo 插入图片"></a>hexo 插入图片</h3><p><a href="https://www.jianshu.com/p/f72aaad7b852">https://www.jianshu.com/p/f72aaad7b852</a><br><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p><p>修改后记得重新生成静态网页</p><figure class="highlight verilog"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-r78x8slax5lwsb"></i><span>verilog</span><div class="collapse" id="collapse-r78x8slax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean<br>hexo <span class="hljs-keyword">generate</span><br>hexo server<br></code></pre></td></tr></table></div></figure><h3 id="生成-ssh-密钥"><a href="#生成-ssh-密钥" class="headerlink" title="生成 ssh 密钥"></a>生成 ssh 密钥</h3><p><a href="https://blog.csdn.net/everything1209/article/details/53100263">https://blog.csdn.net/everything1209/article/details/53100263</a> *无法识别 ssh-keygen<br><a href="https://blog.csdn.net/l508742729/article/details/97510883">https://blog.csdn.net/l508742729/article/details/97510883</a></p><h3 id="添加公钥位置"><a href="#添加公钥位置" class="headerlink" title="添加公钥位置"></a>添加公钥位置</h3><p><a href="https://blog.csdn.net/soulwyb/article/details/90680676">https://blog.csdn.net/soulwyb/article/details/90680676</a></p><h3 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h3><p>码云 gitee 搭建 hexo 博客，push 上去之后，page 为什么不能自动更新，得手动更新 page？<br>gitee pages pro 才支持自动更新</p><h3 id="解决-hexo-本地与部署不一致问题"><a href="#解决-hexo-本地与部署不一致问题" class="headerlink" title="解决 hexo 本地与部署不一致问题"></a>解决 hexo 本地与部署不一致问题</h3><p>更新后如果除臭，一定要清楚浏览器缓存, 可能受之前 url 影响<br><a href="https://blog.csdn.net/GAI159/article/details/105128186">https://blog.csdn.net/GAI159/article/details/105128186</a></p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>说明：<a href="https://www.baidu.com/link?url=0CwgUjWRuzWKaRnSvEuNEW2mvpwEWyS6ExNWIB2mWJkbk4pnyuEy4MMtbW2C-lP8&amp;wd=&amp;eqid=a5c7c3b7000e164e000000035fad28b7">https://www.baidu.com/link?url=0CwgUjWRuzWKaRnSvEuNEW2mvpwEWyS6ExNWIB2mWJkbk4pnyuEy4MMtbW2C-lP8&amp;wd=&amp;eqid=a5c7c3b7000e164e000000035fad28b7</a></p><p><a href="https://www.zhihu.com/question/24422335">主题推荐</a></p><p>知乎回答：<a href="https://www.zhihu.com/question/24422335/answer/336448834">https://www.zhihu.com/question/24422335/answer/336448834</a><br>主题：<a href="https://github.com/Molunerfinn/hexo-theme-melody">https://github.com/Molunerfinn/hexo-theme-melody</a><br>文档：<a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/#%E7%89%B9%E6%80%A7">https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/#%E7%89%B9%E6%80%A7</a></p><p>部署教程：<a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#%E5%AE%89%E8%A3%85">https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#%E5%AE%89%E8%A3%85</a></p><p>更新内容后，直接刷新浏览器，不行的话重新启动服务器再刷新浏览器</p><h3 id="改个人信息"><a href="#改个人信息" class="headerlink" title="改个人信息"></a>改个人信息</h3><p>Author, title<br>_config.yml 文件</p><h3 id="categories-怎么用"><a href="#categories-怎么用" class="headerlink" title="categories 怎么用"></a>categories 怎么用</h3><p>多级分类</p><p><a href="https://www.cnblogs.com/seayxu/archive/2016/01/25/5156669.html">https://www.cnblogs.com/seayxu/archive/2016/01/25/5156669.html</a></p><figure class="highlight subunit"><i class="fas fa-angle-down collapsed" type="button" data-toggle="collapse" data-target="#collapse-aoqg3tlax5lwsb"></i><span>subunit</span><div class="collapse" id="collapse-aoqg3tlax5lwsb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: gitee+hexo<br>top_img: /imgs/bg1.jpg<br>date: 2020<span class="hljs-string">-11</span><span class="hljs-string">-11</span> 17:59:15<br><span class="hljs-keyword">tags:</span> [gitee, hexo]<br>categories: <br>- web<br>- front-end<br></code></pre></td></tr></table></div></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitee</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
