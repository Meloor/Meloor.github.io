---
title: 基于快排partition求第k大数
date: 2020-12-03 21:39:01
tags: [快排]
categories:
    - 数据结构与算法
    - 算法题
---

参考博客：
[面试题：从 n 个数中找出第 K 大的数](https://blog.csdn.net/orangefly0214/article/details/86527462)

## 适合海量数据的 o(nlogk)的方法

借助外部数据结构（最小堆），也可以不借助外部的数据结构，手动实现一个最小堆。
堆中最多 k 个元素，扫描数组 O(n), 每次向堆中插入元素，删除元素，保持堆中元素是当前最大的 k 的数字。更新堆时间 logk, 总时间 nlogk

## 基于快速排序的 partion 方法，时间复杂度为 o(n)

### [快排](https://blog.csdn.net/Meloor/article/details/88313735)中 partion

- 以从大到小排为例, 数组为 a[]
- 首先选择一个基准数，这里以最右边的数为例。
- 从最左边开始找，只要大于基准数就把它交换到前面。
- 这样共**比较了 n 次**，假设这里交换到前面的数有 i 个，那么 a[i]就是基准数存放的位置。
- 然后**以基准数为分界线**把需要排序的数组分为左右两部分。
- 继续对子数组进行分割，直到其长度为 1。

### paritition 求第 k 大

part1:

- 以从大到小排为例, 数组为 a[]
- 首先选择一个基准数，这里以最右边的数为例。
- 从最左边开始找，只要大于基准数就把它交换到前面。
- 这样共**比较了 O(n)次**，假设这里交换到前面的数有 i 个，那么 a[i]就是基准数存放的位置。
- 然后**以基准数为分界线**把需要排序的数组分为左右两部分。

part2:

- 如果 i==k-1 ,那么 a[i]就是数组的第 k 大数；
- 否则, 通过判断下标，只计算包含了索引为 k-1 的那一半，再次 partition

### 例子：[6,7,4,5,2,1,3]求第 2 大数

目标位置：k-1=1

- 初始数组 **[6,7,4,5,2,1,3]**
- 第一轮 partition, 以 3 为基准点，[6,7,4,5,3,1,2], i=4>1, 继续 partition 包含索引为 1 的那一部分 **[6,7,4,5]**
- 第二轮 partition, 以 5 为基准点，[6,7,5,4], i=2>1, 继续 partion **[6,7]**
- 第三轮 partition, 以 7 为基准点，[7,6], i=0<1, 继续 partion **[6]**
- 6 即为所求的第 2 大数

### 时间复杂度为 O(n)

- 快排，每次划分将数组一分为二，且花费 n 的时间（第二轮要 partition 两次，加起来为 n...），最多划分 logn 次, 总时间 O(nlogn)

- partition 求第 k 大，第一次划分为 n，第二次划分为 n/2，..., 最多划分 logn 次，总和小于 2n
  - 如 n=8, s=8+4+2+1=15<16
